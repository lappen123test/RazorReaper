@page "/game"
@using System.Diagnostics
@using System.Runtime.InteropServices
@using Microsoft.JSInterop
@using Microsoft.Extensions.Logging
@using Microsoft.Extensions.Options
@using RazorReaper.Components.Shared
@using RazorReaper.Services
@using RazorReaper.Configuration

@inject IJSRuntime JSRuntime
@inject IProcessService ProcessService
@inject IOptions<AppConfiguration> Configuration
@inject ILogger<Game> Logger

@implements IAsyncDisposable

<div class="app-container game-page-container">
    <RazorReaper.Components.Shared.SharedNavbar />

    <main class="main-content">
        <div class="game-page-content">
            <header class="page-header">
                <h1 class="page-title">Game Management</h1>
                <p class="page-subtitle">Control & Monitor ARK: Survival Evolved</p>
            </header>

            <div class="content-card">
                <div class="game-status">
                    <div class="status-indicator">
                        <div class="status-dot @(isGameRunning ? "online" : "offline")"></div>
                        <div class="status-info">
                            <h3>ARK: Survival Evolved</h3>
                            <span class="status-text">@(isGameRunning ? "Running" : "Not Running")</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="content-card">
                <div class="game-actions">
                    <button class="game-btn primary" @onclick="LaunchGame" disabled="@isGameRunning">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polygon points="5 3 19 12 5 21 5 3" />
                        </svg>
                        Launch Game
                    </button>

                    <button class="game-btn danger" @onclick="CloseGame" disabled="@(!isGameRunning)">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <rect x="3" y="3" width="18" height="18" rx="2" ry="2" />
                            <line x1="9" y1="9" x2="15" y2="15" />
                            <line x1="15" y1="9" x2="9" y2="15" />
                        </svg>
                        Close Game
                    </button>

                    <button class="game-btn success" @onclick="ExecuteReconnect" disabled="@(!isGameRunning)">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M21 12c0 4.97-4.03 9-9 9s-9-4.03-9-9 4.03-9 9-9c2.35 0 4.48.9 6.07 2.38" />
                            <polyline points="21 4 21 12 13 12" />
                        </svg>
                        Reconnect
                    </button>

                    <button class="game-btn warning" @onclick="ExecuteDisconnect" disabled="@(!isGameRunning)">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M18.36 6.64a9 9 0 1 1-12.73 0" />
                            <line x1="12" y1="2" x2="12" y2="12" />
                        </svg>
                        Disconnect
                    </button>

                    <button class="game-btn info" @onclick="ExecuteDebugStructures" disabled="@(!isGameRunning)">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z" />
                        </svg>
                        debugstructures
                    </button>
                </div>
            </div>

        </div>

    </main>
</div>

@code {
    private const int SW_RESTORE = 9;
    private const uint KEYEVENTF_KEYUP = 0x0002;
    private const uint VK_TAB = 0x09;
    private const uint VK_RETURN = 0x0D;

    [DllImport("user32.dll")]
    private static extern bool SetForegroundWindow(IntPtr hWnd);
    [DllImport("user32.dll")]
    private static extern bool ShowWindow(IntPtr hWnd, int nCmdShow);
    [DllImport("user32.dll")]
    private static extern void keybd_event(byte bVk, byte bScan, uint dwFlags, UIntPtr dwExtraInfo);
    [DllImport("user32.dll")]
    private static extern IntPtr GetForegroundWindow();

    private bool isGameRunning = false;
    private Timer? statusTimer;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await JSRuntime.InvokeVoidAsync("eval", @"
                document.onselectstart = function() { return false; };
                document.onmousedown = function(e) {
                    if (!e.target.closest('button')) {
                        e.preventDefault();
                        return false;
                    }
                };
                document.ondragstart = function() { return false; };
                document.oncontextmenu = function() { return false; };

                if (window.getSelection) {
                    window.getSelection().removeAllRanges();
                }

                document.addEventListener('selectstart', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    return false;
                }, true);

                document.addEventListener('mousedown', function(e) {
                    if (!e.target.closest('button')) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                }, true);

                var style = document.createElement('style');
                style.innerHTML = '* { user-select: none !important; -webkit-user-select: none !important; }';
                document.head.appendChild(style);
            ");
        }
    }

    protected override void OnInitialized()
    {
        CheckGameStatus();

        statusTimer = new Timer(async _ =>
        {
            CheckGameStatus();
            await InvokeAsync(StateHasChanged);
        }, null, TimeSpan.Zero, TimeSpan.FromSeconds(5));
    }

    private void CheckGameStatus()
    {
        try
        {
            var processName = Configuration.Value.Ark.GameProcessName;
            isGameRunning = ProcessService.IsProcessRunning(processName);
            Logger.LogDebug("Game status checked: {IsRunning}", isGameRunning);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error checking game status");
            isGameRunning = false;
        }
    }

    private async Task ExecuteReconnect()
    {
        await ExecuteGameCommand("reconnect");
    }

    private async Task ExecuteDisconnect()
    {
        await ExecuteGameCommand("disconnect");
    }

    private async Task ExecuteDebugStructures()
    {
        await ExecuteGameCommand("debugstructures");
    }

    private async Task ExecuteGameCommand(string command)
    {
        try
        {
            Logger.LogInformation("Executing game command: {Command}", command);
            var processName = Configuration.Value.Ark.GameProcessName;
            Process[] processes = ProcessService.GetProcessesByName(processName);
            if (processes.Length > 0)
            {
                IntPtr gameWindowHandle = processes[0].MainWindowHandle;

                ShowWindow(gameWindowHandle, SW_RESTORE);
                await Task.Delay(100);
                SetForegroundWindow(gameWindowHandle);
                await Task.Delay(500);

                keybd_event((byte)VK_TAB, 0, 0, UIntPtr.Zero);
                await Task.Delay(50);
                keybd_event((byte)VK_TAB, 0, KEYEVENTF_KEYUP, UIntPtr.Zero);
                await Task.Delay(300);

                foreach (char c in command.ToLower())
                {
                    SendChar(c);
                    await Task.Delay(50);
                }

                await Task.Delay(200);

                keybd_event((byte)VK_RETURN, 0, 0, UIntPtr.Zero);
                await Task.Delay(50);
                keybd_event((byte)VK_RETURN, 0, KEYEVENTF_KEYUP, UIntPtr.Zero);
            }
            else
            {
                await JSRuntime.InvokeVoidAsync("alert", "ARK: Survival Evolved is not running!");
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error executing game command: {Command}", command);
            await JSRuntime.InvokeVoidAsync("alert", $"Error: {ex.Message}");
        }

        StateHasChanged();
    }

    private void SendChar(char c)
    {
        byte vk = (byte)char.ToUpper(c);
        keybd_event(vk, 0, 0, UIntPtr.Zero);
        keybd_event(vk, 0, KEYEVENTF_KEYUP, UIntPtr.Zero);
    }

    private async Task LaunchGame()
    {
        try
        {
            Logger.LogInformation("Launching ARK via Steam");
            ProcessService.Start("steam://rungameid/346110");

            await Task.Delay(5000);
            CheckGameStatus();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error launching game");
            await JSRuntime.InvokeVoidAsync("alert", $"Error launching game: {ex.Message}");
        }

        StateHasChanged();
    }

    private async Task CloseGame()
    {
        try
        {
            Logger.LogInformation("Closing ARK");
            var processName = Configuration.Value.Ark.GameProcessName;
            Process[] processes = ProcessService.GetProcessesByName(processName);
            foreach (var process in processes)
            {
                ProcessService.Kill(process);
                process.WaitForExit(5000);
            }

            CheckGameStatus();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error closing game");
            await JSRuntime.InvokeVoidAsync("alert", $"Error closing game: {ex.Message}");
        }

        StateHasChanged();
    }

    public async ValueTask DisposeAsync()
    {
        if (statusTimer != null)
        {
            await statusTimer.DisposeAsync();
        }
    }
}